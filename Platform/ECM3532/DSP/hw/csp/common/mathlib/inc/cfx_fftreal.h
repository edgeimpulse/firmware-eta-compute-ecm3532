/*File::   cfx_fftreal.h                                                             */
/*$Revision:: 55766                                                                    $*/
/*$Date:: 2015-06-19 18:45:02 +0300 (Fri, 19 Jun 2015)                                 $*/
/* -----------------------------------------------------------------------------------	*/
/* Copyright (c) 2006, 2007, 2008 NXP B.V.                                              */
/* All rights reserved.                                                                 */
/* This source code and any compilation or derivative thereof is the                    */
/* proprietary information of NXP B.V. and                                              */
/* is confidential in nature.                                                           */
/*                                                                                      */
/* Under no circumstances is this software to be combined with any Open                 */
/* Source Software in any way or placed under an Open Source License of                 */
/* any type without the express written permission of                                   */
/* NXP B.V.                                                                             */
/* -----------------------------------------------------------------------------------	*/

/*
Author      : Thierry Rancurel

Synopsis:     Prototypes of the real fft and ifft, structures, 
and defines to select x or y memory.

**********************************************************************/

#ifndef __fftreal
#define __fftreal
#include "cf6_chess.h"
#include "mathlib.h"
//#include "coolFlux_defs.h"
//#include "cfx_ffttables.h"

//	Real FFT with scaling - Process the first 2 stages only 
//	and then calls compute_inner_stages_stagescaling_bb_ip_process()
int cfx_fft_r_stagescaling_Process (fix *in_buff1,
                                    fix *out_buff1,
                                    int b,
                                    const CFX_FFT_TABLE * table) property(loop_levels_3);

//	Real FFT with scaling - Process the first 2 stages only, inplace
//	and then calls compute_inner_stages_stagescaling_bb_ip_process()
int cfx_fft_r_stagescaling_inplace_Process (fix * in_buff1,
                                            int b,
                                            const CFX_FFT_TABLE * table) property(loop_levels_3);

//	Real FFT without scaling - Process the first 2 stages only 
//	and then calls compute_inner_stages_noscaling_bb_ip_process()
int cfx_fft_r_noscaling_Process (fix *	in_buff1,
                                 fix * out_buff1,
                                 int b,
                                 const CFX_FFT_TABLE * table) property(loop_levels_3);

//	Real FFT - Block Scaling
int cfx_fft_r_blockscaling_Process (fix *in_buff1,
                                    fix *out_buff1,
                                    int b,
                                    const CFX_FFT_TABLE * table,
                                    int scale) property(loop_levels_3);

//	Inverse real FFT with stage scaling with constant downscaling factor of 2, applied at every stage
//	This implements the 1/N factor from the definition
int cfx_ifft_r_stagescaling_Process (fix *in_buff1,
                                     fix *out_buff1,
                                     int b,
                                     const CFX_FFT_TABLE * table) property(loop_levels_3);

//	Inverse real FFT without scaling
//	Result is the real result with a factor N higher
//	However if the input is generated by applying a stagescaling FFt, then the result is correct
int cfx_ifft_r_noscaling_Process (fix *in_buff1,
                                  fix *out_buff1,
                                  int b,
                                  const CFX_FFT_TABLE * table) property(loop_levels_3);

//	Reorder the memory to get a vector representing the real part
//	and a vector representing the imaginary part
int	cfx_fft_reorder_memory(fix *in_buff1,
                           fix *out_buff1,
                           fix *out_buff2,
                           int b) property(loop_levels_1);

#if (defined COOLFLUX_HAS_wide_fix)
//	Real FFT with scaling - Process the first 2 stages only 
//	and then calls compute_inner_stages_stagescaling_bb_ip_process()
int cfx_fft_r_stagescaling_Process_wide (wide_fix *in_buff1,
                                         wide_fix *out_buff1,
                                         int b,
                                         const CFX_FFT_TABLE_WIDE * table) property(loop_levels_3);

//	Real FFT with scaling - Process the first 2 stages only, inplace
//	and then calls compute_inner_stages_stagescaling_bb_ip_process()
int cfx_fft_r_stagescaling_inplace_Process_wide (wide_fix * in_buff1,
                                                 int b,
                                                 const CFX_FFT_TABLE_WIDE * table) property(loop_levels_3);

//	Real FFT without scaling - Process the first 2 stages only 
//	and then calls compute_inner_stages_noscaling_bb_ip_process()
int cfx_fft_r_noscaling_Process_wide (wide_fix *	in_buff1,
                                      wide_fix * out_buff1,
                                      int b,
                                      const CFX_FFT_TABLE_WIDE * table) property(loop_levels_3);

//	Real FFT - Block Scaling
int cfx_fft_r_blockscaling_Process_wide (wide_fix *in_buff1,
                                         wide_fix *out_buff1,
                                         int b,
                                         const CFX_FFT_TABLE_WIDE * table,
                                         int scale) property(loop_levels_3);

//	Inverse real FFT with stage scaling with constant downscaling factor of 2, applied at every stage
//	This implements the 1/N factor from the definition
int cfx_ifft_r_stagescaling_Process_wide (wide_fix *in_buff1,
                                          wide_fix *out_buff1,
                                          int b,
                                          const CFX_FFT_TABLE_WIDE * table) property(loop_levels_3);

//	Inverse real FFT without scaling
//	Result is the real result with a factor N higher
//	However if the input is generated by applying a stagescaling FFt, then the result is correct
int cfx_ifft_r_noscaling_Process_wide (wide_fix *in_buff1,
                                       wide_fix *out_buff1,
                                       int b,
                                       const CFX_FFT_TABLE_WIDE * table) property(loop_levels_3);

//	Reorder the memory to get a vector representing the real part
//	and a vector representing the imaginary part
int	cfx_fft_reorder_memory_wide(wide_fix *in_buff1,
                                wide_fix *out_buff1,
                                wide_fix *out_buff2,
                                int b) property(loop_levels_1);
#endif //#if (defined COOLFLUX_HAS_wide_fix)

#endif